"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringErrorValidator = exports.ObjectErrorValidator = void 0;
const consts_1 = require("../consts");
const IO_1 = require("../utils/IO");
class ObjectErrorValidator {
    /* istanbul ignore next */
    constructor(fsExistRepo = new IO_1.FSExistsRepo()) {
        this.fsExistRepo = fsExistRepo;
    }
    execute(value) {
        var _a;
        if (this.noInDir(value.inDir)) {
            return consts_1.noSuchThing;
        }
        if (!value.outDir) {
            return consts_1.noOutDir;
        }
        if (this.outDirExists(value.outDir)) {
            return consts_1.directoryNotEmpty;
        }
        /* istanbul ignore next */
        if (((_a = value === null || value === void 0 ? void 0 : value.number) !== null && _a !== void 0 ? _a : 2) < 2) {
            return consts_1.notEnoughCurlies;
        }
        return false;
    }
    noInDir(inDir) {
        console.log("inDir:", inDir);
        return !this.fsExistRepo.execute(inDir);
    }
    outDirExists(outDir) {
        return this.fsExistRepo.execute(outDir);
    }
}
exports.ObjectErrorValidator = ObjectErrorValidator;
class StringErrorValidator {
    /* istanbul ignore next */
    constructor(fsExistRepo = new IO_1.FSExistsRepo()) {
        this.fsExistRepo = fsExistRepo;
        this.execute = (inDir, outDir, _vars, number) => {
            if (!this.fsExistRepo.execute(inDir)) {
                return consts_1.noSuchThing;
            }
            if (!outDir) {
                return consts_1.noSuchThing;
            }
            if (this.fsExistRepo.execute(outDir)) {
                return consts_1.directoryNotEmpty;
            }
            if ((number !== null && number !== void 0 ? number : 2) < 2) {
                return consts_1.notEnoughCurlies;
            }
            return false;
        };
    }
}
exports.StringErrorValidator = StringErrorValidator;
//# sourceMappingURL=ErrorValidator.service.js.map