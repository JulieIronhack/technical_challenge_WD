"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetAllService = exports.GetAllServiceSync = void 0;
const path_1 = require("path");
const utils_1 = require("../utils");
const IO_1 = require("../utils/IO");
class GetAllServiceSync {
    constructor(fsOps = new IO_1.FsOperationsSync()) {
        this.fsOps = fsOps;
        this._folders = new Set();
        this._files = new Set();
    }
    getAllFolders(source) {
        this._folders.add(source);
        const [result, error] = this.fsOps.readdir(source);
        if (error) {
            throw new Error(error.message);
        }
        const folders = result.filter((e) => e.isDirectory());
        for (const dir of folders) {
            const res = (0, path_1.resolve)(source, dir.name);
            if (dir.isDirectory()) {
                this.getAllFolders(res);
            }
            else {
                continue;
            }
        }
        return [...this._folders];
    }
    setFolders(source) {
        this._folders = new Set(this.getAllFolders(source));
    }
    get folderArr() {
        return [...this._folders];
    }
    folders(source, base) {
        this.setFolders(source);
        return utils_1.Content.makeFolderStruct(this.folderArr, base);
    }
    getAllFiles(source) {
        const [subDirs, error] = this.fsOps.readdir(source);
        if (error) {
            throw new Error(error.message);
        }
        const files = subDirs.map((dir) => {
            const res = (0, path_1.resolve)(source, dir.name);
            return dir.isDirectory() ? this.getAllFiles(res) : res;
        });
        return files.reduce((a, f) => a.concat(f), []);
    }
    setFiles(source) {
        this._files = new Set(this.getAllFiles(source));
    }
    get fileArr() {
        return [...this._files];
    }
    files(source, baseName) {
        this.setFiles(source);
        return utils_1.Content.makeFileStruct(this.fileArr, baseName);
    }
}
exports.GetAllServiceSync = GetAllServiceSync;
class GetAllService {
    constructor(fsOps = new IO_1.FsOperations()) {
        this.fsOps = fsOps;
        this._folders = new Set();
        this._files = new Set();
    }
    getAllFolders(source) {
        return __awaiter(this, void 0, void 0, function* () {
            this._folders.add(source);
            const [result, error] = yield this.fsOps.readdir(source);
            if (error) {
                throw new Error(error.message);
            }
            const folders = result.filter((e) => e.isDirectory());
            for (const dir of folders) {
                const res = (0, path_1.resolve)(source, dir.name);
                if (dir.isDirectory()) {
                    yield this.getAllFolders(res);
                }
                else {
                    continue;
                }
            }
            return [...this._folders];
        });
    }
    setFolders(source) {
        return __awaiter(this, void 0, void 0, function* () {
            this._folders = new Set(yield this.getAllFolders(source));
        });
    }
    get folderArr() {
        return [...this._folders];
    }
    folders(source, base) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setFolders(source);
            return utils_1.Content.makeFolderStruct(this.folderArr, base);
        });
    }
    getAllFiles(source) {
        return __awaiter(this, void 0, void 0, function* () {
            const [subDirs, error] = yield this.fsOps.readdir(source);
            if (error) {
                throw new Error(error.message);
            }
            const files = yield Promise.all(subDirs.map((dir) => __awaiter(this, void 0, void 0, function* () {
                const res = (0, path_1.resolve)(source, dir.name);
                return dir.isDirectory() ? this.getAllFiles(res) : res;
            })));
            return files.reduce((a, f) => a.concat(f), []);
        });
    }
    setFiles(source) {
        return __awaiter(this, void 0, void 0, function* () {
            this._files = new Set(yield this.getAllFiles(source));
        });
    }
    get fileArr() {
        return [...this._files];
    }
    files(source, baseName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setFiles(source);
            return utils_1.Content.makeFileStruct(this.fileArr, baseName);
        });
    }
}
exports.GetAllService = GetAllService;
//# sourceMappingURL=GetAllService.service.js.map